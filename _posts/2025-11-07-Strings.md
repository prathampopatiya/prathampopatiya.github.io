---
title: Strings
tags: ['#Static analysis', '#Strings', '#MalwareTechLabs']
date: 2025-10-07
---

Lab Name: Strings1 
Download Link: https://labs.malwaretech.com/files/strings/strings1.rar
Rar Password: MalwareTechLabs 

Let's examine the File.
```bash
 file Strings1.exe_ 
Strings1.exe_: PE32+ executable (GUI) x86-64, for MS Windows, 5 sections

```

As the lab description says we need to solve the challenge by using only static analysis.

**Method-1**
Open the file in radare2.
```bash
[0x140001860]> afl
0x140001860    1     91 entry0
0x1400017a0    9    178 sym.Strings1.exe__md5_hash
0x140001000    1     41 fcn.140001000
0x1400010a0   13    640 fcn.1400010a0
0x140001320   11    383 fcn.140001320
0x140001030    1    106 fcn.140001030
0x1400014a0   12    619 fcn.1400014a0
0x140001710    3    144 fcn.140001710
[0x140001860]> pdf @entry0
            ;-- rip:
┌ 91: entry0 (int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4);
│ `- args(rcx, rdx, r8, r9) vars(5:sp[0x8..0x40])
│           0x140001860      44894c2420     mov dword [var_20h], r9d   ; arg4
│           0x140001865      4c89442418     mov qword [var_18h], r8    ; arg3
│           0x14000186a      4889542410     mov qword [var_10h], rdx   ; arg2
│           0x14000186f      48894c2408     mov qword [var_8h], rcx    ; arg1
│           0x140001874      4883ec38       sub rsp, 0x38
│           0x140001878      b808000000     mov eax, 8
│           0x14000187d      4869c0d603..   imul rax, rax, 0x3d6
│           0x140001884      488d0d457e..   lea rcx, [0x1400196d0]
│           0x14000188b      488b0c01       mov rcx, qword [rcx + rax] ; int64_t arg1
│           0x14000188f      e80cffffff     call sym.Strings1.exe__md5_hash
│           0x140001894      4889442420     mov qword [lpText], rax
│           0x140001899      41b930000000   mov r9d, 0x30              ; '0' ; 48 ; UINT uType
│           0x14000189f      4c8d0532be..   lea r8, str.MalwareTech_Labs ; 0x14001d6d8 ; "MalwareTech Labs" ; LPCSTR lpCaption
│           0x1400018a6      488b542420     mov rdx, qword [lpText]    ; LPCSTR lpText
│           0x1400018ab      33c9           xor ecx, ecx               ; HWND hWnd
│           0x1400018ad      ff1565070000   call qword [sym.imp.USER32.dll_MessageBoxA] ; [0x140002018:8]=0x231c reloc.USER32.dll_MessageBoxA ; int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
│           0x1400018b3      33c9           xor ecx, ecx               ; UINT uExitCode
└           0x1400018b5      ff1545070000   call qword [sym.imp.KERNEL32.dll_ExitProcess] ; [0x140002000:8]=0x2300 reloc.KERNEL32.dll_ExitProcess ; VOID ExitProcess(UINT uExitCode)
[0x140001860]> 
```


if we use **strings** utility to read the strings from the file we notice that there are many flags into the data sections now how do we know which flag is passed to md5 hash function.

![image](https://hackmd.io/_uploads/BJtP5JItle.png)

```bash
│           0x14000187d      4869c0d603..   imul rax, rax, 0x3d6
│           0x140001884      488d0d457e..   lea rcx, [0x1400196d0]
│           0x14000188b      488b0c01       mov rcx, qword [rcx + rax] ; int64_t arg1
│           0x14000188f      e80cffffff     call sym.Strings1.exe__md5_hash

```
from here we can get the address of the exact data string
passed to the MD5 hash function.
```bash
dataItemIndex = 0x3d6*8 + 0x1400196d0 => (0x14001b580)
md5_hash(dataItemIndex)
the string at that address is 

ps 4 @0x14001b580
\xc0\xdb\x00@

1007 0x0000bdc0 0x14000dbc0 32  33   .data   ascii FLAG{NEEDLE-IN-A-HAYSTACK-FOUND}

```

**Method-2**

so let's open the binary in Binary Ninja and get the flag
since this is kinda easy challenge not much work is needed.

![image](https://hackmd.io/_uploads/HJLjYy8Ylg.png)

here binary ninja does the address calculation for you just
click onto the data_14001b580 and there is your flag

![image](https://hackmd.io/_uploads/BJOBcxLtll.png)

this was pretty easy challenge.

-------
Now let's move on to the second challenge.

Lab Name: Strings2 
Download Link: https://labs.malwaretech.com/files/strings/strings2.rar
Rar Password: MalwareTechLabs 

Let's open the file into Radare2 and analyze.

```bash
afl
0x140001860    1    273 entry0
0x1400017a0    9    178 sym.Strings2.exe__md5_hash
0x140001000    1     41 fcn.140001000
0x1400010a0   13    640 fcn.1400010a0
0x140001320   11    383 fcn.140001320
0x140001030    1    106 fcn.140001030
0x1400014a0   12    619 fcn.1400014a0
0x140001710    3    144 fcn.140001710
[0x140001860]> pdf @entry0
            ;-- rip:
┌ 273: entry0 (int64_t arg1, int64_t arg2, int64_t arg3, int64_t arg4);
│ `- args(rcx, rdx, r8, r9) vars(45:sp[0x8..0x60])
│           0x140001860      44894c2420     mov dword [var_20h], r9d   ; arg4
│           0x140001865      4c89442418     mov qword [var_18h], r8    ; arg3
│           0x14000186a      4889542410     mov qword [var_10h], rdx   ; arg2
│           0x14000186f      48894c2408     mov qword [var_8h], rcx    ; arg1
│           0x140001874      4883ec58       sub rsp, 0x58
│           0x140001878      c644242846     mov byte [var_28h], 0x46   ; 'F'
│                                                                      ; [0x46:1]=255 ; 70
│           0x14000187d      c64424294c     mov byte [var_29h], 0x4c   ; 'L'
│                                                                      ; [0x4c:1]=255 ; 76
│           0x140001882      c644242a41     mov byte [var_2ah], 0x41   ; 'A'
│                                                                      ; [0x41:1]=255 ; 65
│           0x140001887      c644242b47     mov byte [var_2bh], 0x47   ; 'G'
│                                                                      ; [0x47:1]=255 ; 71
│           0x14000188c      c644242c7b     mov byte [var_2ch], 0x7b   ; '{'
│                                                                      ; [0x7b:1]=255 ; 123
│           0x140001891      c644242d53     mov byte [var_2dh], 0x53   ; 'S'
│                                                                      ; [0x53:1]=255 ; 83
│           0x140001896      c644242e54     mov byte [var_2eh], 0x54   ; 'T'
│                                                                      ; [0x54:1]=255 ; 84
│           0x14000189b      c644242f41     mov byte [var_2fh], 0x41   ; 'A'
│                                                                      ; [0x41:1]=255 ; 65
│           0x1400018a0      c644243043     mov byte [var_30h], 0x43   ; 'C'
│                                                                      ; [0x43:1]=255 ; 67
│           0x1400018a5      c64424314b     mov byte [var_31h], 0x4b   ; 'K'
│                                                                      ; [0x4b:1]=255 ; 75
│           0x1400018aa      c64424322d     mov byte [var_32h], 0x2d   ; '-'
│                                                                      ; [0x2d:1]=255 ; 45
│           0x1400018af      c644243353     mov byte [var_33h], 0x53   ; 'S'
│                                                                      ; [0x53:1]=255 ; 83
│           0x1400018b4      c644243454     mov byte [var_34h], 0x54   ; 'T'
│                                                                      ; [0x54:1]=255 ; 84
│           0x1400018b9      c644243552     mov byte [var_35h], 0x52   ; 'R'
│                                                                      ; [0x52:1]=255 ; 82
│           0x1400018be      c644243649     mov byte [var_36h], 0x49   ; 'I'
│                                                                      ; [0x49:1]=255 ; 73
│           0x1400018c3      c64424374e     mov byte [var_37h], 0x4e   ; 'N'
│                                                                      ; [0x4e:1]=255 ; 78
│           0x1400018c8      c644243847     mov byte [var_38h], 0x47   ; 'G'
│                                                                      ; [0x47:1]=255 ; 71
│           0x1400018cd      c644243953     mov byte [var_39h], 0x53   ; 'S'
│                                                                      ; [0x53:1]=255 ; 83
│           0x1400018d2      c644243a2d     mov byte [var_3ah], 0x2d   ; '-'
│                                                                      ; [0x2d:1]=255 ; 45
│           0x1400018d7      c644243b41     mov byte [var_3bh], 0x41   ; 'A'
│                                                                      ; [0x41:1]=255 ; 65
│           0x1400018dc      c644243c52     mov byte [var_3ch], 0x52   ; 'R'
│                                                                      ; [0x52:1]=255 ; 82
│           0x1400018e1      c644243d45     mov byte [var_3dh], 0x45   ; 'E'
│                                                                      ; [0x45:1]=255 ; 69
│           0x1400018e6      c644243e2d     mov byte [var_3eh], 0x2d   ; '-'
│                                                                      ; [0x2d:1]=255 ; 45
│           0x1400018eb      c644243f42     mov byte [var_3fh], 0x42   ; 'B'
│                                                                      ; [0x42:1]=255 ; 66
│           0x1400018f0      c644244055     mov byte [var_40h], 0x55   ; 'U'
│                                                                      ; [0x55:1]=255 ; 85
│           0x1400018f5      c644244149     mov byte [var_41h], 0x49   ; 'I'
│                                                                      ; [0x49:1]=255 ; 73
│           0x1400018fa      c64424424c     mov byte [var_42h], 0x4c   ; 'L'
│                                                                      ; [0x4c:1]=255 ; 76
│           0x1400018ff      c644244354     mov byte [var_43h], 0x54   ; 'T'
│                                                                      ; [0x54:1]=255 ; 84
│           0x140001904      c64424442d     mov byte [var_44h], 0x2d   ; '-'
│                                                                      ; [0x2d:1]=255 ; 45
│           0x140001909      c644244541     mov byte [var_45h], 0x41   ; 'A'
│                                                                      ; [0x41:1]=255 ; 65
│           0x14000190e      c644244654     mov byte [var_46h], 0x54   ; 'T'
│                                                                      ; [0x54:1]=255 ; 84
│           0x140001913      c64424472d     mov byte [var_47h], 0x2d   ; '-'
│                                                                      ; [0x2d:1]=255 ; 45
│           0x140001918      c644244852     mov byte [var_48h], 0x52   ; 'R'
│                                                                      ; [0x52:1]=255 ; 82
│           0x14000191d      c644244955     mov byte [var_49h], 0x55   ; 'U'
│                                                                      ; [0x55:1]=255 ; 85
│           0x140001922      c644244a4e     mov byte [var_4ah], 0x4e   ; 'N'
│                                                                      ; [0x4e:1]=255 ; 78
│           0x140001927      c644244b54     mov byte [var_4bh], 0x54   ; 'T'
│                                                                      ; [0x54:1]=255 ; 84
│           0x14000192c      c644244c49     mov byte [var_4ch], 0x49   ; 'I'
│                                                                      ; [0x49:1]=255 ; 73
│           0x140001931      c644244d4d     mov byte [var_4dh], 0x4d   ; 'M'
│                                                                      ; [0x4d:1]=255 ; 77
│           0x140001936      c644244e45     mov byte [var_4eh], 0x45   ; 'E'
│                                                                      ; [0x45:1]=255 ; 69
│           0x14000193b      c644244f7d     mov byte [var_4fh], 0x7d   ; '}'
│                                                                      ; [0x7d:1]=255 ; 125
│           0x140001940      488d4c2428     lea rcx, [var_28h]         ; int64_t arg1
│           0x140001945      e856feffff     call sym.Strings2.exe__md5_hash
│           0x14000194a      4889442420     mov qword [lpText], rax
│           0x14000194f      41b930000000   mov r9d, 0x30              ; '0' ; 48 ; UINT uType
│           0x140001955      4c8d05241b..   lea r8, str.MalwareTech_Labs ; 0x140003480 ; "MalwareTech Labs" ; LPCSTR lpCaption
│           0x14000195c      488b542420     mov rdx, qword [lpText]    ; LPCSTR lpText
│           0x140001961      33c9           xor ecx, ecx               ; HWND hWnd
│           0x140001963      ff15af060000   call qword [sym.imp.USER32.dll_MessageBoxA] ; [0x140002018:8]=0x231c reloc.USER32.dll_MessageBoxA ; int MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType)
│           0x140001969      33c9           xor ecx, ecx               ; UINT uExitCode
└           0x14000196b      ff158f060000   call qword [sym.imp.KERNEL32.dll_ExitProcess] ; [0x140002000:8]=0x2300 reloc.KERNEL32.dll_ExitProcess ; VOID ExitProcess(UINT uExitCode)
[0x140001860]> 
```

Radare already did the work for us.
flag --> FLAG{STACK-STRINGS-ARE-BUILT-AT-RUNTIME}

Now let's do the next challenge.

----

Lab Name: Strings3 
Download Link: https://labs.malwaretech.com/files/strings/strings3.rar
Rar Password: MalwareTechLabs 

let's fire it into radare2.

```c
//pdg @entry0

ulong entry0(void)

{
    ulong uVar1;
    int64_t iVar2;
    uchar *puVar3;
    uchar auStack_408 [1024];
    
    puVar3 = auStack_408;
    for (iVar2 = 0x400; iVar2 != 0; iVar2 = iVar2 + -1) {
        *puVar3 = 0;
        puVar3 = puVar3 + 1;
    }
    (*_sym.imp.KERNEL32.dll_FindResourceA)(0,"Resource.rc",6);
    (*_sym.imp.USER32.dll_LoadStringA)(0,0x110,auStack_408,0x3ff);
    uVar1 = sym.Strings3.exe__md5_hash(auStack_408);
    (*_sym.imp.USER32.dll_MessageBoxA)(0,uVar1,"MalwareTech Labs",0x30);
    (*_sym.imp.KERNEL32.dll_ExitProcess)(0);
    return 0;
}
```

Here the flag is declared as resource and then loaded at runtime from .rsrc section in the PE file. Malwares often use this technique to declare their payload resource and then load it at runtime.

So to locate the exact resource string we need to understand this two lines.

```c
(*_sym.imp.KERNEL32.dll_FindResourceA)(0,"Resource.rc",6);
(*_sym.imp.USER32.dll_LoadStringA) (0,0x110,auStack_408,0x3ff);

// Let's view the MSDN for the above two function

HRSRC FindResourceA(
  [in, optional] HMODULE hModule,
  [in]           LPCSTR  lpName,
  [in]           LPCSTR  lpType
);

int LoadStringA(
  [in, optional] HINSTANCE hInstance,
  [in]           UINT      uID,
  [out]          LPSTR     lpBuffer,
  [in]           int       cchBufferMax
);


RT_STRING
MAKEINTRESOURCE(6)
// lpType 6 refers to string table entry 
// The official MSDN says there are 16 strings per block in the string table so the id:0x110 refers to 
    
int target_uID = 0x110
int block_id = target_uID // 15  
int index_in_block = target_uID % 16
```


Now to locate the reosurce from the .rsrc section we need to parse the resource location from the PE file. To do that
i have used  https://lief.re/. 


```python
import lief
import sys

target_uID = 0x110
block_id = target_uID // 15  # Each block holds 16 strings
index_in_block = target_uID % 16

# Parse the PE file
pe = lief.parse("Strings3.exe_")
if not pe.has_resources:
    print("No resources found!")
    sys.exit(1)

# Find the STRINGTABLE resource type (ID = 6)
string_table_type = next((r for r in pe.resources.childs if r.id == 6), None)
if string_table_type is None:
    print("No STRINGTABLE resource found!")
    sys.exit(1)

# Look for the block that contains our desired string
block_node = next((b for b in string_table_type.childs if b.id == block_id), None)
if block_node is None:
    print(f"No STRINGTABLE block found for ID {block_id}")
    sys.exit(1)

lang_node = block_node.childs[0] 
raw_data = lang_node.content

# Parse UTF-16LE string table
from io import BytesIO

def extract_strings_from_stringtable(data):
    result = []
    stream = BytesIO(bytes(data))
    for _ in range(16):
        # Each string is prefixed with a 2-byte length (in UTF-16 code units)
        length_bytes = stream.read(2)
        if len(length_bytes) < 2:
            break
        length = int.from_bytes(length_bytes, byteorder="little")
        if length == 0:
            result.append("")
            continue
        string_data = stream.read(length * 2)
        try:
            decoded = string_data.decode("utf-16le")
        except UnicodeDecodeError:
            decoded = "<decode error>"
        result.append(decoded)
    return result

# Extract all 16 strings in the block
strings = extract_strings_from_stringtable(raw_data)

# Print the one matching uID = 0x110
print(f"String for uID 0x110 (block {block_id}, index {index_in_block}):")
print(strings[index_in_block])

'''
String for uID 0x110 (block 18, index 0):
FLAG{RESOURCES-ARE-POPULAR-FOR-MALWARE}
'''

```

There is famous tool https://github.com/hasherezade/pe-bear which automatically parses the PE file so its very easy to locate the string from the .rsrc section.

![image](https://hackmd.io/_uploads/Bynqb4OYlg.png)

but i don't recommend to directly use the tool, dig sometime researching in MSDN learn about the PE file structure and it's parsing. the challenge were simple, but they are were very base of malware static analysis, ofcourse this would be very easy to solve in a debugger.

